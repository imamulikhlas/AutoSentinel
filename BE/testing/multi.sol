{

  "language": "Solidity",

  "sources": {

    "contracts/lib/Launchpad.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.29;\n\n// OpenZeppelin\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n// Chainlink\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\n// Local imports\nimport \"./Types.sol\";\nimport \"./Manager.sol\";\nimport \"./MLM.sol\";\nimport \"./Utility.sol\";\n\n/**\n * @title Launchpad\n * @dev A contract to facilitate token launches and sales on a launchpad. Users can mint launchpad tokens in exchange for payment tokens.\n * @dev MLM derives from Manager, exposing manager features to the launchpad\n */\ncontract Launchpad is Initializable, MLM {\n    using SafeERC20 for IERC20Metadata;\n\n    uint256 public constant PRICE_FEED_TIMEOUT = 1 hours;\n\n    // -----------------------------------------\n    // Type declarations\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // State variables\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Events\n    // -----------------------------------------\n    /**\n     * Tokens have been minted\n     * @param user user address\n     * @param amount the amount minted\n     * @param tokenExchangeRate the token exchange rate for this mint\n     */\n    event TokensMinted(\n        address indexed user,\n        uint256 amount,\n        uint256 tokenExchangeRate\n    );\n\n    // -----------------------------------------\n    // Modifiers\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Constructor\n    // -----------------------------------------\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        // Prevents initialization of implementation contract\n        _disableInitializers();\n    }\n\n    // -----------------------------------------\n    // Receive function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Fallback function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // External functions\n    // -----------------------------------------\n    /**\n     * @notice Initializes the contract with owner and configuration parameters\n     * @param owner The address of the contract owner\n     * @param stableCoins An array of addresses of known stable coins.\n     * @param priceFeeds An array of known price feed configurations.\n     * @param config Configuration parameters for the launchpad\n     */\n    function initialize(\n        address owner,\n        address[] calldata stableCoins,\n        Types.PriceFeedConfig[] calldata priceFeeds,\n        Types.LaunchpadConfig calldata config\n    ) external initializer {\n        // Initialize the manager first\n        __Manager_init(owner, stableCoins, priceFeeds, config);\n        __Escrow_init();\n        __MLM_init();\n    }\n\n    /**\n     * @notice Mints new Launchpad tokens using the specified payment token and a referrer ID.\n     * @param paymentTokenAddress The ERC20 token address used for payment. If address(0), it's treated as ETH.\n     * @param amountPaymentToken The amount of payment tokens/ETH to be used for minting.\n     * @param referrerID The referrer ID string used for MLM purposes.\n     * @return amountLaunchpadToken The amount of Launchpad tokens minted and transferred to the sender.\n     */\n    function mint(\n        address paymentTokenAddress,\n        uint256 amountPaymentToken,\n        string calldata referrerID\n    ) external payable returns (uint256 amountLaunchpadToken) {\n        return _mint(paymentTokenAddress, amountPaymentToken, referrerID);\n    }\n\n    /**\n     * @notice Mints new Launchpad tokens using the specified payment token without a referrer ID.\n     * @param paymentTokenAddress The ERC20 token address used for payment. If address(0), it's treated as ETH.\n     * @param amountPaymentToken The amount of payment tokens/ETH to be used for minting.\n     * @return amountLaunchpadToken The amount of Launchpad tokens minted and transferred to the sender.\n     */\n    function mint(\n        address paymentTokenAddress,\n        uint256 amountPaymentToken\n    ) external payable returns (uint256 amountLaunchpadToken) {\n        string memory referrerID = \"\";\n        return _mint(paymentTokenAddress, amountPaymentToken, referrerID);\n    }\n\n    /**\n     * @notice Tops up launchpad tokens for future sales\n     * @param topUpAmount Amount of launchpad tokens to be topped up\n     */\n    function topUpLaunchpadTokens(uint256 topUpAmount) external onlyOwner {\n        if (\n            _launchpadToken.allowance(msg.sender, address(this)) < topUpAmount\n        ) {\n            revert LaunchpadTokenAllowanceTooLow();\n        }\n\n        // Transfer payment token from the sender to the contract\n        _launchpadToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            topUpAmount\n        );\n    }\n\n    /**\n     * @notice Recovers unsold launchpad tokens and sends them to the owner.\n     * @dev The amount recovered is limited to prevent removing tokens reserved for open commissions.\n     * Ensure that only the owner can call this function and no reentrancy is allowed.\n     */\n    function recoverLaunchpadToken() external onlyOwner {\n        uint256 amount = _launchpadToken.balanceOf(address(this));\n\n        // Limit amount of tokens to recover to account for open commissions\n        amount -= openLaunchpadTokenCommissions();\n\n        if (amount == 0) {\n            return;\n        }\n\n        _launchpadToken.safeTransfer(address(owner()), amount);\n    }\n\n    /**\n     * @dev Release deposited ETH or ERC20 tokens for the caller.\n     * @param token The address of the ERC20 token to release, address(0) for ETH\n     */\n    function release(address token) external returns (uint256) {\n        return _release(token);\n    }\n\n    // -----------------------------------------\n    // Public functions\n    // -----------------------------------------\n    /**\n     * @notice Retrieves the latest price for a given payment token\n     * @param paymentTokenAddress Address of the payment token\n     * @return decimals Number of decimals of the price feed\n     * @return price Latest price of the payment token\n     */\n    function getPrice(\n        address paymentTokenAddress\n    ) public view returns (uint8 decimals, uint256 price) {\n        address priceFeedAddress = getPriceFeed(paymentTokenAddress);\n        AggregatorV3Interface feed = AggregatorV3Interface(priceFeedAddress);\n\n        // prettier-ignore\n        (\n            /*uint80 roundID*/,\n            int answer,\n            /*uint256 startedAt*/,\n            uint256 timeStamp,\n            /*uint80 answeredInRound*/\n        ) = feed.latestRoundData();\n\n        if (timeStamp < (block.timestamp - PRICE_FEED_TIMEOUT)) {\n            revert PriceFeedTimedOut();\n        }\n\n        if (answer <= 0) {\n            revert PriceFeedInvalidResponse();\n        }\n\n        decimals = feed.decimals();\n\n        return (decimals, uint256(answer));\n    }\n\n    /**\n     * @notice Converts a payment token amount to a launchpad token amount\n     * @param paymentTokenAddress Address of the payment token\n     * @param amountPaymentToken Amount of payment tokens\n     * @return payout Amount of launchpad tokens\n     */\n    function quote(\n        address paymentTokenAddress,\n        uint256 amountPaymentToken\n    ) public view returns (uint256 payout) {\n        IERC20Metadata paymentToken = IERC20Metadata(paymentTokenAddress);\n\n        // Test remaining input parameters\n        if (amountPaymentToken <= 0) {\n            revert InvalidPaymentTokenAmount();\n        }\n\n        // Determine a USD price to peg payout to USD values\n        uint256 usdValuePaymentToken = 0;\n        uint8 paymentTokenDecimals = 0;\n        if (paymentTokenAddress == address(0)) {\n            paymentTokenDecimals = 18;\n        } else {\n            paymentTokenDecimals = paymentToken.decimals();\n        }\n\n        if (isKnownStableCoin(paymentTokenAddress)) {\n            if (!isAcceptedPaymentToken(paymentTokenAddress)) {\n                revert UnknownPaymentToken();\n            }\n            // Handle payment with stable tokens (USDC, USDT, DAI...), 1:1\n            usdValuePaymentToken =\n                amountPaymentToken *\n                10 ** (18 - paymentTokenDecimals);\n        } else {\n            if (!isAcceptedPaymentToken(paymentTokenAddress)) {\n                revert UnknownPaymentToken();\n            }\n            // Request price\n            (uint8 decimals, uint256 price) = getPrice(paymentTokenAddress);\n\n            // Convert to USD value considering both the price feed and payment token decimals\n            usdValuePaymentToken =\n                (uint256(price) *\n                    amountPaymentToken *\n                    10 ** (18 - paymentTokenDecimals)) /\n                (10 ** decimals);\n        }\n\n        // How many tokens to pay out per dollar?\n        uint256 launchpadTokenDecimals = _launchpadToken.decimals();\n        uint256 base = 10 ** (18 - launchpadTokenDecimals);\n\n        payout = (usdValuePaymentToken * _tokenExchangeRate) / BASIS / base;\n\n        return payout;\n    }\n\n    // -----------------------------------------\n    // Internal functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Private functions\n    // -----------------------------------------\n    /**\n     * @dev Internal function to handle the logic of minting Launchpad tokens.\n     * @param paymentTokenAddress The ERC20 token address used for payment. If address(0), it's treated as ETH.\n     * @param amountPaymentToken The amount of payment tokens/ETH to be used for minting.\n     * @param referrerID The referrer ID string used for MLM purposes.\n     * @return amountLaunchpadToken The amount of Launchpad tokens minted and transferred to the sender.\n     */\n    function _mint(\n        address paymentTokenAddress,\n        uint256 amountPaymentToken,\n        string memory referrerID\n    )\n        private\n        nonReentrant\n        onlyWhenActive\n        onlyUser\n        returns (uint256 amountLaunchpadToken)\n    {\n        // short-circuit evaluation\n        if (_mlmEnabled && Utility.getStringLength(referrerID) == 0) {\n            revert InvalidRefferId();\n        }\n\n        IERC20Metadata paymentToken = IERC20Metadata(paymentTokenAddress);\n\n        if (paymentTokenAddress != address(0)) {\n            // Ensure contract has allowance to transfer specified amount of token\n            if (\n                paymentToken.allowance(msg.sender, address(this)) <\n                amountPaymentToken\n            ) {\n                revert PaymentTokenAllowanceTooLow();\n            }\n\n            // Ensure user has enough tokens to transfer\n            if (paymentToken.balanceOf(msg.sender) < amountPaymentToken) {\n                revert PaymentTokenBalanceTooLow();\n            }\n\n            // Transfer payment token from the sender to the contract\n            paymentToken.safeTransferFrom(\n                msg.sender,\n                address(this),\n                amountPaymentToken\n            );\n        } else {\n            // Check that the value of ETH sent matches the intended amount\n            if (msg.value != amountPaymentToken) {\n                revert IntendedEthAmountMissmatch();\n            }\n        }\n\n        // Get a quote for the launchpad token payout\n        amountLaunchpadToken = quote(paymentTokenAddress, amountPaymentToken);\n\n        // Distribute commission to partners\n        uint256 totalPaymentTokenCommission = 0;\n        for (uint256 i = 0; i < _partners.length; i++) {\n            Types.PartnerConfig memory partnerConfig = _partners[i];\n            // Do not pay commissions if partner is the minter\n            if (partnerConfig.partner == msg.sender) {\n                continue;\n            }\n\n            // Calculate the share for each partner\n            uint256 paymentTokenCommission = (amountPaymentToken *\n                partnerConfig.share) / BASIS;\n\n            // The launchpad token payout is already pegged to the dollar value\n            uint256 launchpadTokenCommission = (amountLaunchpadToken *\n                partnerConfig.share) / BASIS;\n\n            if (\n                partnerConfig.commissionMode ==\n                Types.CommissionMode.PaymentToken ||\n                partnerConfig.commissionMode == Types.CommissionMode.Both\n            ) {\n                // Account for payment token commission\n                _account(\n                    partnerConfig.partner,\n                    paymentTokenAddress,\n                    paymentTokenCommission\n                );\n\n                // Accumulate the total payment token commission\n                totalPaymentTokenCommission += paymentTokenCommission;\n\n                // Emit event to track partner commissions\n                emit Types.CommissionPaid(\n                    partnerConfig.partner,\n                    paymentTokenAddress,\n                    msg.sender,\n                    Types.PARTNER_COMMISSION_LEVEL,\n                    paymentTokenCommission\n                );\n            }\n\n            if (\n                partnerConfig.commissionMode ==\n                Types.CommissionMode.LaunchpadToken ||\n                partnerConfig.commissionMode == Types.CommissionMode.Both\n            ) {\n                // Account for payment token commission\n                _account(\n                    partnerConfig.partner,\n                    address(_launchpadToken),\n                    launchpadTokenCommission\n                );\n\n                // Emit event to track partner commissions\n                emit Types.CommissionPaid(\n                    partnerConfig.partner,\n                    address(_launchpadToken),\n                    msg.sender,\n                    Types.PARTNER_COMMISSION_LEVEL,\n                    launchpadTokenCommission\n                );\n            }\n        }\n\n        // Distribute payment tokens to referrals (MLM)\n        if (_mlmEnabled) {\n            Types.Commission[] memory commission = _getCommissions(\n                referrerID,\n                paymentTokenAddress,\n                amountPaymentToken,\n                amountLaunchpadToken\n            );\n\n            for (uint256 i = 0; i < commission.length; i++) {\n                _account(\n                    commission[i].beneficiary,\n                    commission[i].tokenAddress,\n                    commission[i].amount\n                );\n\n                // Accumulate the total payment token commission\n                if (commission[i].tokenAddress == paymentTokenAddress) {\n                    totalPaymentTokenCommission += commission[i].amount;\n                }\n            }\n        }\n\n        // Calculate the remaining amount after partner shares are deducted\n        uint256 remainingPaymentToken = amountPaymentToken -\n            totalPaymentTokenCommission;\n\n        // Account for the owner share\n        _account(owner(), paymentTokenAddress, remainingPaymentToken);\n\n        // Emit event to track owner commissions\n        emit Types.CommissionPaid(\n            owner(),\n            paymentTokenAddress,\n            msg.sender,\n            Types.OWNER_COMMISSION_LEVEL,\n            remainingPaymentToken\n        );\n\n        // Ensure contract has enough launchpad tokens after accounting for all commissions\n        if (\n            _launchpadToken.balanceOf(address(this)) <\n            (amountLaunchpadToken + openLaunchpadTokenCommissions())\n        ) {\n            revert LaunchpadTokenBalanceTooLow();\n        }\n\n        // Transfer amount of tokens to the sender\n        _launchpadToken.safeTransfer(msg.sender, amountLaunchpadToken);\n        emit TokensMinted(msg.sender, amountLaunchpadToken, _tokenExchangeRate);\n\n        return amountLaunchpadToken;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"

    },

    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"

    },

    "lib/chainlink-evm/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"

    },

    "contracts/lib/Types.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.29;\n\nlibrary Types {\n    // -----------------------------------------\n    // Type declarations\n    // -----------------------------------------\n    /// @notice Represents a multi-level-marketing User\n    struct MlmUser {\n        /// @notice referrral, address(0) if root\n        address referrer;\n        /// @notice the unique referral ID for this user\n        string userReferralID;\n    }\n\n    /// @notice Commission Payout Modes for Partners and MLM\n    enum CommissionMode {\n        /// @notice distribute payment tokens\n        PaymentToken,\n        /// @notice distribute launchpad tokens\n        LaunchpadToken,\n        /// @notice if both, payment token and launchpad token get distributed\n        Both,\n        /// @notice represents the \"uninitialized\" or \"unset\" state\n        None\n    }\n\n    /// @notice Represents a commission\n    struct Commission {\n        /// @notice benficiary, will get this distribution\n        address beneficiary;\n        /// @notice the token in which the commission is payed, address(0) for native (ETH, BNB)\n        address tokenAddress;\n        /// @notice the amount rewarded\n        uint256 amount;\n    }\n    /// @notice Represents a partner configuration within a system.\n    struct PartnerConfig {\n        /// @notice The payout address of the partner.\n        address partner;\n        /// @notice The share of the partner expressed in basis points (hundredths of a percent).\n        uint256 share;\n        /// @notice The partner comission mode\n        CommissionMode commissionMode;\n    }\n\n    /// @notice Represents a designated address configuration within a system.\n    struct DesignatedAddressConfig {\n        /// @notice The payout address of the designated address.\n        address da;\n        /// @notice The share of the designated address expressed in basis points (hundredths of a percent).\n        uint256 share;\n    }\n\n    /// @notice Represents the price feed configuration for a particular token.\n    struct PriceFeedConfig {\n        /// @notice The address of the token.\n        address token;\n        /// @notice The address of the price feed for the token.\n        address feed;\n    }\n\n    /// @notice Represents the configuration for a token launchpad.\n    struct LaunchpadConfig {\n        /// @notice The address of the launchpad token.\n        address launchpadToken;\n        /// @notice The exchange rate for converting dollar to launchpad tokens.\n        uint256 tokenExchangeRate;\n        /// @notice The UTC timestamp marking the beginning of the launchpad event.\n        uint256 start;\n        /// @notice The UTC timestamp marking the end of the launchpad event.\n        uint256 end;\n        /// @notice An array of launchpad partners.\n        PartnerConfig[] partners;\n        /// @notice An array of addresses of tokens accepted for payments.\n        address[] paymentTokens;\n        /// @notice The maximum total shares for partners, in basis points\n        uint256 maxTotalSharePartners;\n        /// @notice The maximum total shares for multi-level-marketing levels, in basis points\n        uint256 maxTotalShareMlmLevels;\n        /// @notice The maximum total shares for designated addresses, in basis points\n        uint256 maxTotalShareDesignatedAddress;\n        /// @notice The multi-level-marketing levels (rates per level in basis points, [level0, level1 ...])\n        /// where level0 is the first referrer, level1 is the second referrer...\n        uint256[] mlmLevels;\n        /// @notice The comission payout mode for MLM\n        CommissionMode mlmCommissionMode;\n    }\n\n    // -----------------------------------------\n    // State variables\n    // -----------------------------------------\n    uint8 constant DA_COMMISSION_LEVEL = type(uint8).max;\n    uint8 constant PARTNER_COMMISSION_LEVEL = type(uint8).max - 1;\n    uint8 constant OWNER_COMMISSION_LEVEL = type(uint8).max - 2;\n\n    // -----------------------------------------\n    // Events\n    // -----------------------------------------\n    /**\n     * Commission Event\n     * @param beneficiary beneficiary of this commission\n     * @param paymentTokenAddress the payment token address\n     * @param user the user who caused the commission payment\n     * @param level either the MLM level or special identifier (DA, partner)\n     * @param amount the commission amount\n     */\n    event CommissionPaid(\n        address indexed beneficiary,\n        address indexed paymentTokenAddress,\n        address indexed user,\n        uint8 level,\n        uint256 amount\n    );\n\n    // -----------------------------------------\n    // Modifiers\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Constructor\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Receive function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Fallback function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // External functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Public functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Internal functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Private functions\n    // -----------------------------------------\n}\n"

    },

    "contracts/lib/Manager.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.29;\n\n// OpenZeppelin\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\n// Local Imports\nimport {Types} from \"./Types.sol\";\nimport \"./Error.sol\";\nimport {ILaunchpadToken} from \"../interfaces/ILaunchpadToken.sol\";\n\n/**\n * @title A Launchpad Manager\n * @notice A contract for managing a launchpad, including configuration and state\n * @dev This contract also manages Multi-Level-Marketing settings\n */\nabstract contract Manager is Error, Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    // -----------------------------------------\n    // Type declarations\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // State variables\n    // -----------------------------------------\n\n    // Basis for percentage calculations\n    uint256 public constant BASIS = 10_000; // Basis points for percentage calculations\n\n    // AUDIT: These constants might change before deployment, for risk assessment consider\n    uint256 public constant MAX_NUM_PARTNERS = 100; // Maximum 100 partners\n    uint256 public constant MAX_NUM_DESIGNATED_ADDRESSES = 100; // Maximum 100 designated addresses in a path\n    uint256 internal constant MAX_MLM_TREE_DEPTH = 500; // Maximum 500 iterations in the MLM tree depth\n    uint256 public constant MAX_MLM_LEVELS = 7; // Maximum 7 levels for multi-level-marketing\n    uint256 public constant MAX_LAUNCHPAD_TIME = 730 * 24 * 60 * 60; // Maximum launchpad time (2 Years)\n    uint256 public constant MAX_TOKEN_EXCHANGE_RATE = 100_000_000 * BASIS; // Maximum tokens per dollar\n\n    // Share-Settings, config parameters\n    uint256 public MAX_TOTAL_SHARE_PARTNERS; // Maximum payout for partner\n    uint256 public MAX_TOTAL_SHARE_MLM_LEVELS; // Maximum payout for partner\n    uint256 public MAX_TOTAL_SHARE_DESIGNATED_ADDRESS; // Maximum payout for a designated address\n\n    // variables\n    IERC20Metadata internal _launchpadToken; // Token to be launched\n\n    // Manage the token exchange rate\n    uint256 internal _tokenExchangeRate; // Token exchange rate\n\n    // Mange timestamps\n    uint256 internal _start; // Launchpad start time (UTC)\n    uint256 internal _end; // Launchpad end time (UTC)\n\n    // Manage partner configuration\n    Types.PartnerConfig[] internal _partners; // Partners involved in the launchpad\n    mapping(address => bool) internal _knownPartners; // Known partners\n\n    // Manage initial contract settings (known stable coins and price feeds for payment tokens)\n    mapping(address => bool) internal _stableCoins; // Supported stablecoins\n    mapping(address => address) internal _priceFeeds; // Supported price feeds\n\n    // Manage accepted payment tokens\n    address[] internal _paymentTokensLut; // Accepted payment tokens lookup table\n    mapping(address => bool) internal _acceptedPaymentToken; // Accepted payment token\n\n    // Manage designated addresses for MLM\n    Types.DesignatedAddressConfig[] internal _designatedAddresses; // Designated addresses involved in the launchpad\n    mapping(address => bool) internal _knownDesignatedAddresses; // Known designated addresses\n    mapping(address => uint256) internal _designatedAddressesShare; // The designated addresses share\n\n    // Manage levels (reward shares) for MLM\n    uint256[] internal _mlmLevels;\n    bool internal _mlmEnabled;\n    Types.CommissionMode internal _mlmCommissionMode;\n\n    // -----------------------------------------\n    // Events\n    // -----------------------------------------\n    /**\n     * a partner was added or modified\n     * @param partner the partner\n     * @param share the share rate\n     * @param commissionMode the commission mode\n     */\n    event PartnerChanged(\n        address indexed partner,\n        uint256 share,\n        Types.CommissionMode commissionMode\n    );\n    /**\n     * a designated address was added or modified\n     * @param da the address\n     * @param share the share rate\n     */\n    event DesignatedAddressChanged(address indexed da, uint256 share);\n    /**\n     * a partner was removed\n     * @param partner the partner\n     */\n    event PartnerRemoved(address indexed partner);\n    /**\n     * a designated address was removed\n     * @param da the address\n     */\n    event DesignatedAddressRemoved(address indexed da);\n    /**\n     * start timestamp has changed\n     * @param start the new start time\n     */\n    event StartChanged(uint256 indexed start);\n    /**\n     * end timestamp has changed\n     * @param end the new end time\n     */\n    event EndChanged(uint256 indexed end);\n    /**\n     * the MLM commission mode has changed\n     * @param mode the new mode\n     */\n    event MlmCommissionModeChanged(Types.CommissionMode mode);\n    /**\n     * the MLM levels have changed\n     * @param levels the new levels\n     * @param isActive true if active, else false\n     */\n    event MlmLevelsChanged(uint256[] levels, bool isActive);\n    /**\n     * the token exchange rate has changed\n     * @param rate the new token exchange rate\n     */\n    event TokenExchangeRateChanged(uint256 rate);\n    // -----------------------------------------\n    // Modifiers\n    // -----------------------------------------\n    /**\n     * ensures that the launchpad is active\n     */\n    modifier onlyWhenActive() {\n        if (!isActive()) {\n            revert LaunchpadNotActive();\n        }\n        _;\n    }\n\n    /**\n     * The owner is considered not to be a user\n     * - Partners and Dedicated addresses are allowed to mint (and hence can particiapte in MLM)\n     */\n    modifier onlyUser() {\n        if (msg.sender == owner()) {\n            revert MintingNotAllowedForAddress();\n        }\n        _;\n    }\n\n    // -----------------------------------------\n    // Receive function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Fallback function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // External functions\n    // -----------------------------------------\n    /**\n     * @notice Modify the launchpad commission mode, only the owner of the launchpad can modify\n     * @param commissionMode the new commission mode, must not be none\n     */\n    function setMlmCommissionMode(\n        Types.CommissionMode commissionMode\n    ) external onlyOwner {\n        if (hasEnded()) {\n            revert LaunchpadHasEnded();\n        }\n        if (commissionMode == Types.CommissionMode.None) {\n            revert MlmNewCommissionModeMustNotBeNone();\n        }\n\n        _mlmCommissionMode = commissionMode;\n\n        emit MlmCommissionModeChanged(commissionMode);\n    }\n\n    /**\n     * @notice Sets the token exchange rate\n     * @param tokenExchangeRate The new token exchange rate\n     * Emits:\n     *  - `TokenExchangeRateChanged` on token exchange rate change\n     */\n    function setTokenExchangeRate(\n        uint256 tokenExchangeRate\n    ) external onlyOwner {\n        if (hasEnded()) {\n            revert LaunchpadHasEnded();\n        }\n        if (tokenExchangeRate == 0) {\n            revert InvalidTokenExchangeRate();\n        }\n        if (tokenExchangeRate > MAX_TOKEN_EXCHANGE_RATE) {\n            revert InvalidTokenExchangeRate();\n        }\n        _tokenExchangeRate = tokenExchangeRate;\n\n        emit TokenExchangeRateChanged(_tokenExchangeRate);\n    }\n\n    /**\n     * @notice Sets the launchpad start time\n     * @param start The new start time\n     */\n    function setStart(uint256 start) external onlyOwner {\n        if (hasEnded()) {\n            revert LaunchpadHasEnded();\n        }\n        if (isActive()) {\n            revert LaunchpadIsActive();\n        }\n        if (start < block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        if (start >= _end) {\n            revert InvalidTimestamp();\n        }\n        if (_end > start + MAX_LAUNCHPAD_TIME) {\n            revert InvalidTimestamp();\n        }\n        _start = start;\n\n        emit StartChanged(start);\n    }\n\n    /**\n     * @notice Sets the launchpad end time\n     * @param end The new end time\n     */\n    function setEnd(uint256 end) external onlyOwner {\n        if (hasEnded()) {\n            revert LaunchpadHasEnded();\n        }\n        if (end <= _start) {\n            revert InvalidTimestamp();\n        }\n        if (end > _start + MAX_LAUNCHPAD_TIME) {\n            revert InvalidTimestamp();\n        }\n        _end = end;\n\n        emit EndChanged(end);\n    }\n\n    /**\n     * @notice Removes a partner address from the contract.\n     * Only the contract owner can call this function.\n     * The function does not allow removals after the launchpad has ended and ensures that the given address is a known partner before removal.\n     * The removal mechanism is optimized for gas by swapping the partner to remove with the last one in the list, then popping the last entry.\n     *\n     * @param partner The partner address to be removed.\n     *\n     * Requirements:\n     * - Caller must be the contract owner.\n     * - Launchpad must not have ended.\n     * - `partner` must be a known partner.\n     *\n     * Emits:\n     * - `PartnerRemoved` event after successful removal.\n     */\n    function removePartner(address partner) external onlyOwner {\n        if (hasEnded()) {\n            revert LaunchpadHasEnded();\n        }\n        if (!_knownPartners[partner]) {\n            revert InvalidAddress();\n        }\n\n        // Initialize with an invalid value\n        uint256 indexToDelete = _partners.length;\n\n        // Locate the partner\n        for (uint256 i = 0; i < indexToDelete; i++) {\n            if (_partners[i].partner == partner) {\n                indexToDelete = i;\n                break;\n            }\n        }\n\n        // Swap with the last partner and remove\n        _partners[indexToDelete] = _partners[_partners.length - 1];\n        _partners.pop();\n\n        // Update the mapping\n        delete _knownPartners[partner];\n\n        emit PartnerRemoved(partner);\n    }\n\n    /**\n     * @notice Removes a designated address from the contract.\n     * Only the contract owner can call this function.\n     * The function does not allow removals after the launchpad has ended and ensures that the given address is known before removal.\n     * The removal approach is optimized for gas by swapping the address to remove with the last in the list, then performing a pop operation.\n     *\n     * @param da The designated address to be removed.\n     *\n     * Requirements:\n     * - Caller must be the contract owner.\n     * - Launchpad must not have ended.\n     * - `da` must be a known designated address.\n     *\n     * Emits:\n     * - `DesignatedAddressRemoved` event after successful removal.\n     */\n    function removeDesignatedAddress(address da) external onlyOwner {\n        if (hasEnded()) {\n            revert LaunchpadHasEnded();\n        }\n        if (!_knownDesignatedAddresses[da]) {\n            revert InvalidAddress();\n        }\n\n        // Initialize with an invalid value\n        uint256 indexToDelete = _designatedAddresses.length;\n\n        // Locate the partner\n        for (uint256 i = 0; i < indexToDelete; i++) {\n            if (_designatedAddresses[i].da == da) {\n                indexToDelete = i;\n                break;\n            }\n        }\n\n        // Swap with the last partner and remove\n        _designatedAddresses[indexToDelete] = _designatedAddresses[\n            _designatedAddresses.length - 1\n        ];\n        _designatedAddresses.pop();\n\n        // Update the mapping\n        delete _knownDesignatedAddresses[da];\n        delete _designatedAddressesShare[da];\n\n        emit DesignatedAddressRemoved(da);\n    }\n\n    /**\n     * @notice Sets or updates a designated address along with its associated share rate.\n     * Only the contract owner can call this function.\n     * Designated address must meet several conditions:\n     * - Must not be the zero address.\n     * - Must have minted at least once.\n     * - Must not be a known partner.\n     * - Share assigned should be greater than zero and within allowable limits.\n     * If the designated address is not previously known, it will be added; otherwise, its share will be updated.\n     *\n     * @param da The designated address to modify or add.\n     * @param share The share rate for this designated address.\n     *\n     * Requirements:\n     * - Caller must be the contract owner.\n     * - `da` must not be the zero address.\n     * - `da` must have minted at least once.\n     * - `da` must not be a known partner.\n     * - `share` should be greater than 0.\n     * - `share` must not exceed the `MAX_TOTAL_SHARE_DESIGNATED_ADDRESS`.\n     * - Total number of designated addresses after adding must not exceed `MAX_NUM_DESIGNATED_ADDRESSES`.\n     *\n     * Emits:\n     * - `DesignatedAddressChanged` event after successful change.\n     */\n    function manageDesignatedAddress(\n        address da,\n        uint256 share\n    ) external onlyOwner {\n        if (da == address(0)) {\n            revert InvalidAddress();\n        }\n        if (!isMlmEnabled()) {\n            revert MlmDisabled();\n        }\n        if (!mlmUserExists(da)) {\n            revert MlmUserDoesNotExist();\n        }\n        if (_knownPartners[da]) {\n            revert MlmUserIsPartner();\n        }\n        if (share == 0) {\n            revert InvalidShareRate();\n        }\n        if (share > MAX_TOTAL_SHARE_DESIGNATED_ADDRESS) {\n            revert InvalidShareRate();\n        }\n\n        uint256 daCount = _designatedAddresses.length;\n        bool exists = _knownDesignatedAddresses[da];\n\n        if (exists) {\n            for (uint i = 0; i < daCount; i++) {\n                if (_designatedAddresses[i].da == da) {\n                    _designatedAddresses[i].share = share;\n                    break;\n                }\n            }\n        } else {\n            if (daCount + 1 >= MAX_NUM_DESIGNATED_ADDRESSES) {\n                revert OutOfBoundary();\n            }\n            // add new designated address\n            _designatedAddresses.push(\n                Types.DesignatedAddressConfig({da: da, share: share})\n            );\n            _knownDesignatedAddresses[da] = true;\n        }\n\n        // Update share mapping\n        _designatedAddressesShare[da] = share;\n        emit DesignatedAddressChanged(da, share);\n    }\n\n    /**\n     * @notice allow to see the token exchange rate (tokens per dollar)\n     */\n    function getTokenExchangeRate() external view returns (uint256) {\n        return _tokenExchangeRate;\n    }\n\n    /**\n     * @notice get the MLM commission mode\n     */\n    function getMlmCommissionMode()\n        external\n        view\n        returns (Types.CommissionMode)\n    {\n        return _mlmCommissionMode;\n    }\n\n    /**\n     * @notice Retrieves the list of all registered partner addresses.\n     * @return An array containing all the partner configurations.\n     */\n    function getPartners()\n        external\n        view\n        returns (Types.PartnerConfig[] memory)\n    {\n        return _partners;\n    }\n\n    /**\n     * @notice Retrieves the list of all designated addresses.\n     * @return An array containing all the designated addresses configurations.\n     */\n    function getDesignatedAddresses()\n        external\n        view\n        returns (Types.DesignatedAddressConfig[] memory)\n    {\n        return _designatedAddresses;\n    }\n\n    /**\n     * @notice Gets all payment token addreses enabled for this launchpad\n     */\n    function getPaymentTokens() external view returns (address[] memory) {\n        return _paymentTokensLut;\n    }\n\n    /**\n     * @notice Gets the launchpad start time\n     */\n    function getStart() external view returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @notice Gets the launchpad end time\n     */\n    function getEnd() external view returns (uint256) {\n        return _end;\n    }\n\n    /**\n     * @notice Checks if the launchpad is pending\n     */\n    function isPending() external view returns (bool) {\n        return block.timestamp < _start;\n    }\n\n    /**\n     * @notice Get MLM levels (frontends)\n     */\n    function getMlmLevels() external view returns (uint256[] memory) {\n        return _mlmLevels;\n    }\n\n    // -----------------------------------------\n    // Public functions\n    // -----------------------------------------\n    /**\n     * @notice replaces the MLM levels. An empty array will disable MLM\n     * The first referrer corresponds to level 0, the referrals referrer to level 1...\n     * The array looks like: [level0, level1, level2...]\n     * @param mlmLevels the new mlm levels\n     */\n    function setMlmLevels(uint256[] calldata mlmLevels) public onlyOwner {\n        if (hasEnded()) {\n            revert LaunchpadHasEnded();\n        }\n        if (mlmLevels.length > MAX_MLM_LEVELS) {\n            revert OutOfBoundary();\n        }\n        uint256 totalRate = 0;\n        for (uint256 i = 0; i < mlmLevels.length; i++) {\n            totalRate += mlmLevels[i];\n        }\n        if (totalRate > MAX_TOTAL_SHARE_MLM_LEVELS) {\n            revert OutOfBoundary();\n        }\n        _mlmLevels = mlmLevels;\n        _mlmEnabled = _mlmLevels.length > 0;\n\n        emit MlmLevelsChanged(mlmLevels, _mlmEnabled);\n    }\n\n    /**\n     * @notice Allows the owner to add a new partner or update the share of an existing partner.\n     * @param partner The address of the partner.\n     * @param share The share assigned to the partner.\n     * @param commissionMode The commission mode assigned to a partner. If none, the commission mode will not be updated.\n     * @dev If the partner address already exists in the list, this function updates its share.\n     * Otherwise, it adds the address as a new partner. After modification, the function checks\n     * to ensure the total shares of all partners don't exceed `MAX_TOTAL_SHARE_PARTNERS`.\n     *\n     * Requirements:\n     * - Only the contract owner can call this function.\n     * - The launchpad must not have ended.\n     * - A partner cannot simultaneously be a designated address.\n     * - The assigned share must be greater than zero.\n     * - Partner address must not be the zero address.\n     * - The total number of partners after potential addition must be below the `MAX_NUM_PARTNERS`.\n     * - The cumulative shares of all partners must not exceed `MAX_TOTAL_SHARE_PARTNERS`.\n     *\n     * Emits:\n     * - `PartnerChanged` event after successful change.\n     */\n    function managePartnerAddress(\n        address partner,\n        uint256 share,\n        Types.CommissionMode commissionMode\n    ) public onlyOwner {\n        if (hasEnded()) {\n            revert LaunchpadHasEnded();\n        }\n        if (_knownDesignatedAddresses[partner]) {\n            revert MlmIsDesignatedAddress();\n        }\n        if (share == 0) {\n            revert InvalidShareRate();\n        }\n        if (partner == address(0)) {\n            revert InvalidAddress();\n        }\n\n        uint256 partnersCount = _partners.length;\n        bool exists = _knownPartners[partner];\n\n        // Update existing partner\n        if (exists) {\n            for (uint i = 0; i < partnersCount; i++) {\n                if (_partners[i].partner == partner) {\n                    _partners[i].share = share;\n                    if (commissionMode != Types.CommissionMode.None) {\n                        _partners[i].commissionMode = commissionMode;\n                    }\n                    break;\n                }\n            }\n        } else {\n            if (partnersCount + 1 >= MAX_NUM_PARTNERS) {\n                revert OutOfBoundary();\n            }\n            // Add new partner\n            _partners.push(\n                Types.PartnerConfig({\n                    partner: partner,\n                    share: share,\n                    commissionMode: commissionMode\n                })\n            );\n            _knownPartners[partner] = true;\n            partnersCount++;\n        }\n\n        uint totalPartnerShares = 0;\n        for (uint i = 0; i < partnersCount; i++) {\n            totalPartnerShares += _partners[i].share;\n        }\n\n        if (totalPartnerShares > MAX_TOTAL_SHARE_PARTNERS) {\n            revert TotalPartnerSharesExceeded();\n        }\n\n        emit PartnerChanged(partner, share, commissionMode);\n    }\n\n    /**\n     * @notice Checks if a token address is accepted for payment\n     */\n    function isAcceptedPaymentToken(\n        address tokenAddress\n    ) public view returns (bool) {\n        return _acceptedPaymentToken[tokenAddress];\n    }\n\n    /**\n     * @notice Gets the price feed for a token\n     */\n    function getPriceFeed(address tokenAddress) public view returns (address) {\n        if (_priceFeeds[tokenAddress] == address(0)) {\n            revert InvalidAddress();\n        }\n        return _priceFeeds[tokenAddress];\n    }\n\n    /**\n     * @notice Checks if a token address is a known stablecoin\n     */\n    function isKnownStableCoin(\n        address tokenAddress\n    ) public view returns (bool) {\n        return _stableCoins[tokenAddress];\n    }\n\n    /**\n     * @notice Checks if the launchpad is active\n     */\n    function isActive() public view returns (bool) {\n        return block.timestamp >= _start && block.timestamp <= _end;\n    }\n\n    /**\n     * @notice Checks if the launchpad has ended\n     */\n    function hasEnded() public view returns (bool) {\n        return block.timestamp > _end;\n    }\n\n    /**\n     * @notice Get the launchpad token address\n     */\n    function getLaunchpadTokenAddress() public view returns (address) {\n        return address(_launchpadToken);\n    }\n\n    /**\n     * @notice True if MLM is enabled, false otherwise\n     */\n    function isMlmEnabled() public view returns (bool) {\n        return _mlmEnabled;\n    }\n\n    /**\n     * @notice Allows to check if an address is a MLM user\n     */\n    function mlmUserExists(address user) public view virtual returns (bool);\n\n    // -----------------------------------------\n    // Internal functions\n    // -----------------------------------------\n    /**\n     * @notice Initializes the launchpad with the given configuration\n     * @param owner launchpad owner (must be launchpad token deployer)\n     * @param stableCoins An array of addresses of known stable coins.\n     * @param priceFeeds An array of known price feed configurations.\n     * @param config Configuration parameters for the launchpad\n     */\n    function __Manager_init(\n        address owner,\n        address[] calldata stableCoins,\n        Types.PriceFeedConfig[] calldata priceFeeds,\n        Types.LaunchpadConfig calldata config\n    ) internal onlyInitializing {\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n\n        // Initialise share settings\n        MAX_TOTAL_SHARE_PARTNERS = config.maxTotalSharePartners;\n        MAX_TOTAL_SHARE_MLM_LEVELS = config.maxTotalShareMlmLevels;\n        MAX_TOTAL_SHARE_DESIGNATED_ADDRESS = config\n            .maxTotalShareDesignatedAddress;\n\n        if (\n            (MAX_TOTAL_SHARE_PARTNERS +\n                MAX_TOTAL_SHARE_MLM_LEVELS +\n                MAX_TOTAL_SHARE_DESIGNATED_ADDRESS) > BASIS\n        ) {\n            revert OutOfBoundary();\n        }\n\n        // Initialise timestamps\n        if (config.start < block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        if (config.end <= config.start) {\n            revert InvalidTimestamp();\n        }\n        if (config.end > (config.start + MAX_LAUNCHPAD_TIME)) {\n            revert InvalidTimestamp();\n        }\n        _end = config.end;\n        _start = config.start;\n\n        // Initialise MLM Levels\n        setMlmLevels(config.mlmLevels);\n\n        // Initialise MLM Share Distribution Mode\n        if (config.mlmCommissionMode == Types.CommissionMode.None) {\n            revert InitialCommissionModeMustNotBeNone();\n        }\n        _mlmCommissionMode = config.mlmCommissionMode;\n\n        // Initialise known stablecoins (validated by the factory)\n        for (uint256 i = 0; i < stableCoins.length; i++) {\n            _stableCoins[stableCoins[i]] = true;\n        }\n\n        // Initialise known price feeds (validated by the factory)\n        for (uint256 i = 0; i < priceFeeds.length; i++) {\n            // explicitely allow price feed for zero address (ETH, BNB...)\n            _priceFeeds[priceFeeds[i].token] = priceFeeds[i].feed;\n        }\n\n        // Initialise token exchange rate\n        if (config.tokenExchangeRate == 0) {\n            revert InvalidTokenExchangeRate();\n        }\n        if (config.tokenExchangeRate > MAX_TOKEN_EXCHANGE_RATE) {\n            revert InvalidTokenExchangeRate();\n        }\n        _tokenExchangeRate = config.tokenExchangeRate;\n\n        // Initiliase accepted payment tokens\n        for (uint256 i = 0; i < config.paymentTokens.length; i++) {\n            if (_acceptedPaymentToken[config.paymentTokens[i]]) {\n                revert HasDuplicatedValues();\n            }\n\n            // Either it is a known stablecoin\n            if (_stableCoins[config.paymentTokens[i]]) {\n                _acceptedPaymentToken[config.paymentTokens[i]] = true;\n                continue;\n            }\n            // Or we have an oracle\n            if (_priceFeeds[config.paymentTokens[i]] != address(0)) {\n                _acceptedPaymentToken[config.paymentTokens[i]] = true;\n                continue;\n            }\n            // Else, revert\n            revert UnknownPaymentToken();\n        }\n        _paymentTokensLut = config.paymentTokens;\n\n        // Initiliase partners and check boundaries\n        for (uint256 i = 0; i < config.partners.length; i++) {\n            if (_knownPartners[config.partners[i].partner]) {\n                revert HasDuplicatedValues();\n            }\n            if (\n                config.partners[i].commissionMode == Types.CommissionMode.None\n            ) {\n                revert InitialCommissionModeMustNotBeNone();\n            }\n            managePartnerAddress(\n                config.partners[i].partner,\n                config.partners[i].share,\n                config.partners[i].commissionMode\n            );\n        }\n\n        // Finally initiliase the launchpad token\n        if (config.launchpadToken == address(0)) {\n            revert InvalidAddress();\n        }\n        if (!_isLaunchpadToken(owner, config.launchpadToken)) {\n            revert TokenNotAcceptedForLaunchpad();\n        }\n        _launchpadToken = IERC20Metadata(config.launchpadToken);\n        if (_launchpadToken.totalSupply() == 0) {\n            revert TokenNotAcceptedForLaunchpad();\n        }\n\n        // Transfer ownership to the provided owner address\n        transferOwnership(owner);\n    }\n\n    // -----------------------------------------\n    // Private functions\n    // -----------------------------------------\n    /**\n     * @dev Checks if the given address is a valid Launchpad Token.\n     *\n     * This function checks if the provided token address meets the following criteria:\n     * 1. The owner of the launchpad must be the deployer of the token contract.\n     * 2. The token contract must have a function `isLaunchpadToken` that returns true.\n     * 3. Or: the token is ownable and the token owner is the launchpad owner\n     *\n     * If either of these conditions are not met, or if any exceptions are encountered,\n     * the function returns false.\n     *\n     * @param owner The launchpad owner.\n     * @param tokenAddress The address of the token to check.\n     * @return bool true if the address corresponds to a valid Launchpad Token; otherwise false.\n     * @notice The token contract at `tokenAddress` must have a `deployer` function that\n     *         returns the deployer's address, and an `isLaunchpadToken` function that\n     *         returns a boolean indicating if it's a Launchpad Token.\n     *         Or: token is ownable and launchpad owner is token owner\n     */\n    function _isLaunchpadToken(\n        address owner,\n        address tokenAddress\n    ) private view returns (bool) {\n        try OwnableUpgradeable(tokenAddress).owner() returns (address tokenOwner) {\n            // allow token owner\n            if (owner == tokenOwner) {\n                return true;\n            } else {\n                // do nothing, could still implement launchpad token interface\n            }\n        } catch (bytes memory) {\n            // do nothing\n        }\n\n        try ILaunchpadToken(tokenAddress).deployer() returns (\n            address deployerAddress\n        ) {\n            if (owner != deployerAddress) {\n                return false;\n            }\n        } catch {\n            return false;\n        }\n\n        try ILaunchpadToken(tokenAddress).isLaunchpadToken() returns (\n            bool isLaunchpadToken\n        ) {\n            return isLaunchpadToken;\n        } catch {\n            return false;\n        }\n    }\n\n    uint256[34] __gap;\n}\n"

    },

    "contracts/lib/MLM.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.29;\n\nimport {Types} from \"./Types.sol\";\nimport {Escrow} from \"./Escrow.sol\";\nimport {Utility} from \"./Utility.sol\";\n\n/**\n * @title Multi-Level-Marketing Contract\n * @dev A contract to calculate MLM distribution\n */\nabstract contract MLM is Escrow {\n    // -----------------------------------------\n    // Type declarations\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // State variables\n    // -----------------------------------------\n    /// @custom:storage-location erc7201:genielaunchpad.storage.MLMStorage\n    struct MLMStorage {\n        mapping(address => Types.MlmUser) _users;\n        mapping(address => bool) _userExists;\n        mapping(string => address) _idToAddress;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"genielaunchpad.storage.MLMStorage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant MLMStorageLocation =\n        0xe04b7af5653a94335ff8e5bbdf4f3e710dd03b6b2a7c13f4d46aa29423019c00;\n\n    // -----------------------------------------\n    // Events\n    // -----------------------------------------\n    /**\n     * Emitted when a new user is onboarded\n     * @param referrer the referrer\n     * @param user the user\n     */\n    event UserOnboarded(address indexed referrer, address indexed user);\n\n    // -----------------------------------------\n    // Modifiers\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Constructor\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Receive function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Fallback function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // External functions\n    // -----------------------------------------\n    /**\n     * @notice Gets the referrer ID for the caller (must mint once)\n     * @return Referral ID string\n     */\n    function getUserReferralID(\n        address userAddress\n    ) external view returns (string memory) {\n        MLMStorage storage $ = _getMLMStorage();\n\n        if (!$._userExists[userAddress]) {\n            revert MlmUserDoesNotExist();\n        }\n\n        return $._users[userAddress].userReferralID;\n    }\n\n    // -----------------------------------------\n    // Public functions\n    // -----------------------------------------\n    /**\n     * @notice Checks if a user exists in the MLM structure\n     * @param userAddress Address of the user to check\n     * @return bool indicating if the user exists\n     */\n    function mlmUserExists(\n        address userAddress\n    ) public view override returns (bool) {\n        return _getMLMStorage()._userExists[userAddress];\n    }\n\n    /**\n     * @notice Checks if a referral id is valid - belongs to one of the users\n     * @param referralId Referral ID string\n     * @return bool indicating if the user with provided referralId exists\n     */\n    function referrerExist(\n        string memory referralId\n    ) external view returns (bool) {\n        return _getMLMStorage()._idToAddress[referralId] != address(0);\n    }\n\n    // -----------------------------------------\n    // Internal functions\n    // -----------------------------------------\n    /**\n     * @dev Internal function to initialize MLM structure with the owner\n     *\n     * Emits:\n     * - `UserOnboarded` to indicate root of MLM tree\n     */\n    function __MLM_init() internal onlyInitializing {\n        MLMStorage storage $ = _getMLMStorage();\n\n        address userAddress = owner();\n        string memory userReferralID = _generateReferralID(userAddress);\n\n        $._idToAddress[userReferralID] = userAddress;\n        $._userExists[userAddress] = true;\n        $._users[userAddress] = Types.MlmUser({\n            referrer: address(0),\n            userReferralID: userReferralID\n        });\n\n        // Emit with refferer == address(0) to mark root of MLM-tree\n        emit UserOnboarded(address(0), userAddress);\n    }\n\n    /**\n     * @dev Calculates commissions for referrals\n     * @param referrerID Referral ID\n     * @param paymentTokenAddress Address of the token used for payment\n     * @param amountPaymentToken Amount of tokens used for payment\n     * @param amountLaunchpadToken Amount minted by this transaction\n     * @return Array of MLM rewards\n     *\n     * Emits:\n     * - `UserOnboarded` if user is new\n     * - `CommissionPaid` when a commission is paid to a user\n     */\n    function _getCommissions(\n        string memory referrerID,\n        address paymentTokenAddress,\n        uint256 amountPaymentToken,\n        uint256 amountLaunchpadToken\n    ) internal returns (Types.Commission[] memory) {\n        MLMStorage storage $ = _getMLMStorage();\n\n        address referrerAddress = $._idToAddress[referrerID];\n\n        // The refferal must exist\n        if (referrerAddress == address(0)) {\n            revert InvalidAddress();\n        }\n\n        // Users cannot reffer themselves\n        if (referrerAddress == msg.sender) {\n            revert InvalidAddress();\n        }\n\n        _onboardUser($, msg.sender, referrerAddress);\n\n        // Iterate the tree till we hit the root or a designated address\n        uint8 level = 0;\n\n        // Only the first designated address gets a reward\n        bool foundDesignatedAddress = false;\n\n        // commissions, will be remapped later\n        // one commission per level + 1 designated address,\n        // if mlm commission mode is both, account for two commissions\n        // payment token and launchpad token\n        Types.Commission[] memory rewards = new Types.Commission[](\n            (_mlmLevels.length + 1) *\n                (_mlmCommissionMode == Types.CommissionMode.Both ? 2 : 1)\n        );\n        uint256 rewardCounter = 0;\n\n        // tree-depth\n        uint256 treeDepth = 1;\n\n        // Iterate from the user level upwards\n        Types.MlmUser memory iterator = $._users[msg.sender];\n        while (iterator.referrer != owner()) {\n            uint8 comissionPaidEventLevel = level;\n\n            // Abort iterating if we hit the maximum tree size\n            if (treeDepth >= MAX_MLM_TREE_DEPTH) {\n                revert MlmMaxTreeDepth();\n            }\n\n            uint256 share = 0;\n\n            // Payout shares within MLM levels first\n            if (level < _mlmLevels.length) {\n                // Get the share rate for this level\n                share = _mlmLevels[level];\n\n                // increase level index\n                ++level;\n            }\n\n            // Search for dedicated address\n            if (\n                _knownDesignatedAddresses[iterator.referrer] &&\n                !foundDesignatedAddress\n            ) {\n                share += _designatedAddressesShare[iterator.referrer];\n                comissionPaidEventLevel = Types.DA_COMMISSION_LEVEL;\n\n                // Found a designated address, only the first gets rewarded\n                foundDesignatedAddress = true;\n            }\n\n            // Share found, process\n            if (share > 0) {\n                if (\n                    _mlmCommissionMode == Types.CommissionMode.PaymentToken ||\n                    _mlmCommissionMode == Types.CommissionMode.Both\n                ) {\n                    uint256 paymentTokenAmount = (amountPaymentToken * share) /\n                        BASIS;\n\n                    rewards[rewardCounter] = Types.Commission({\n                        beneficiary: iterator.referrer,\n                        amount: paymentTokenAmount,\n                        tokenAddress: paymentTokenAddress\n                    });\n\n                    emit Types.CommissionPaid(\n                        iterator.referrer,\n                        paymentTokenAddress,\n                        msg.sender,\n                        comissionPaidEventLevel,\n                        paymentTokenAmount\n                    );\n\n                    ++rewardCounter;\n                }\n\n                if (\n                    _mlmCommissionMode == Types.CommissionMode.LaunchpadToken ||\n                    _mlmCommissionMode == Types.CommissionMode.Both\n                ) {\n                    uint256 launchpadTokenAmount = (amountLaunchpadToken *\n                        share) / BASIS;\n\n                    rewards[rewardCounter] = Types.Commission({\n                        beneficiary: iterator.referrer,\n                        amount: launchpadTokenAmount,\n                        tokenAddress: address(_launchpadToken)\n                    });\n\n                    emit Types.CommissionPaid(\n                        iterator.referrer,\n                        address(_launchpadToken),\n                        msg.sender,\n                        level,\n                        launchpadTokenAmount\n                    );\n\n                    ++rewardCounter;\n                }\n            }\n\n            // stop iterating if we out of MLM levels and found designated address,\n            // all other designated addresses are skipped\n            if (level > _mlmLevels.length && foundDesignatedAddress) {\n                break;\n            }\n\n            // move upwards\n            iterator = $._users[iterator.referrer];\n            ++treeDepth;\n        }\n\n        // Create a new, smaller array to hold the populated rewards\n        Types.Commission[] memory finalRewards = new Types.Commission[](\n            rewardCounter\n        );\n\n        for (uint256 i = 0; i < rewardCounter; ++i) {\n            finalRewards[i] = rewards[i];\n        }\n\n        return finalRewards;\n    }\n\n    function _onboardUser(\n        MLMStorage storage $,\n        address userAddress,\n        address referrerAddress\n    ) internal {\n        if (!$._userExists[userAddress]) {\n            string memory userReferralID = _generateReferralID(userAddress);\n\n            $._users[userAddress] = Types.MlmUser({\n                referrer: referrerAddress,\n                userReferralID: userReferralID\n            });\n\n            $._idToAddress[userReferralID] = userAddress;\n            $._userExists[userAddress] = true;\n\n            emit UserOnboarded(referrerAddress, userAddress);\n\n            return;\n        }\n\n        // The referrer must stay the same for a user\n        if ($._users[userAddress].referrer != referrerAddress) {\n            revert MlmCannotChangeReferrer();\n        }\n    }\n\n    // -----------------------------------------\n    // Private functions\n    // -----------------------------------------\n    function _getMLMStorage() private pure returns (MLMStorage storage $) {\n        assembly {\n            $.slot := MLMStorageLocation\n        }\n    }\n\n    /**\n     * @dev Generates a referrer ID based on the provided user address\n     * @param userAddress Address of the user for which to generate the referrer ID\n     * @return string containing the generated referrer ID\n     */\n    function _generateReferralID(\n        address userAddress\n    ) private view returns (string memory) {\n        bytes32 secretSalt = keccak256(\n            abi.encodePacked(\n                block.timestamp,\n                msg.sender,\n                owner(),\n                getLaunchpadTokenAddress(),\n                block.prevrandao\n            )\n        );\n\n        bytes32 hashed = keccak256(abi.encodePacked(userAddress, secretSalt));\n\n        return Utility.toHexString(hashed);\n    }\n}\n"

    },

    "contracts/lib/Utility.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.29;\n\nlibrary Utility {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    // -----------------------------------------\n    // Type declarations\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // State variables\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Events\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Modifiers\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Constructor\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Receive function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Fallback function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // External functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Public functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Internal functions\n    // -----------------------------------------\n    function getStringLength(string memory str) internal pure returns (uint256) {\n        bytes memory strBytes = bytes(str);\n        return strBytes.length;\n    }\n\n    /**\n     * @dev Converts a bytes32 value to its hex string representation\n     * @param value bytes32 value to convert\n     * @return string containing the hex representation of the input value\n     */\n    function toHexString(bytes32 value) internal pure returns (string memory) {\n        bytes memory str = new bytes(64);\n\n        for (uint256 i = 0; i < 32; i++) {\n            str[i * 2] = HEX_DIGITS[uint8(value[i] >> 4)];\n            str[1 + i * 2] = HEX_DIGITS[uint8(value[i] & 0x0f)];\n        }\n\n        return string(str);\n    }\n\n    // -----------------------------------------\n    // Private functions\n    // -----------------------------------------\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"

    },

    "lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "lib/openzeppelin-contracts-upgradeable/contracts/utils/ReentrancyGuardUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"

    },

    "contracts/lib/Error.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.29;\n\ninterface Error {\n    // -----------------------------------------\n    // Type declarations\n    // -----------------------------------------\n    // Minting Errors\n    error MintingNotAllowedForAddress();\n\n    // Launchpad\n    error InvalidTimestamp();\n    error InvalidShareRate();\n    error TokenNotAcceptedForLaunchpad();\n    error UnknownPaymentToken();\n    error PaymentTokenAllowanceTooLow();\n    error LaunchpadTokenAllowanceTooLow();\n    error IntendedEthAmountMissmatch();\n    error LaunchpadTokenBalanceTooLow();\n    error PaymentTokenBalanceTooLow();\n\n    // Price\n    error PriceFeedTimedOut();\n    error PriceFeedInvalidResponse();\n\n    // Qoutes\n    error InvalidPaymentTokenAmount();\n\n    // Parameters\n    error LaunchpadNotActive();\n    error LaunchpadHasEnded();\n    error LaunchpadIsActive();\n    error InvalidTokenExchangeRate();\n    error InvalidAddress();\n    error OutOfBoundary();\n    error HasDuplicatedValues();\n    error InitialCommissionModeMustNotBeNone();\n    error TotalPartnerSharesExceeded();\n\n    // MLM Errors\n    error MlmDisabled();\n    error MlmUserDoesNotExist();\n    error MlmUserIsPartner();\n    error MlmWrongParam();\n    error MlmIsDesignatedAddress();\n    error MlmCannotChangeReferrer();\n    error MlmNewCommissionModeMustNotBeNone();\n    error MlmMaxTreeDepth();\n\n    // Escrow\n    error NothingToRelease();\n    error FatalEscrowError();\n    error InvalidRefferId();\n\n    // -----------------------------------------\n    // State variables\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Events\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Modifiers\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Constructor\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Receive function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Fallback function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // External functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Public functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Internal functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Private functions\n    // -----------------------------------------\n}\n"

    },

    "contracts/interfaces/ILaunchpadToken.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\ninterface ILaunchpadToken {\n    // -----------------------------------------\n    // Type declarations\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // State variables\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Events\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Modifiers\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Constructor\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Receive function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Fallback function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // External functions\n    // -----------------------------------------\n    /**\n     * @dev Returns the address of the contract deployer\n     */\n    function deployer() external view returns (address);\n\n    /**\n     * @dev Returns true if the token is explicitely allowed for Genie Launchpads\n     */\n    function isLaunchpadToken() external view returns (bool);\n\n    // -----------------------------------------\n    // Public functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Internal functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Private functions\n    // -----------------------------------------\n}\n"

    },

    "contracts/lib/Escrow.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.29;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {Manager} from \"./Manager.sol\";\n\n/**\n * @title Escrow\n * @dev A contract to hold and release ETH or ERC20 tokens for beneficiaries.\n */\nabstract contract Escrow is Manager {\n    using SafeERC20 for IERC20;\n\n    // -----------------------------------------\n    // Type declarations\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // State variables\n    // -----------------------------------------\n    /// @custom:storage-location erc7201:genielaunchpad.storage.EscrowStorage\n    struct EscrowStorage {\n        // Storage for holding beneficiaries' token balances\n        mapping(address => mapping(address => uint256)) _holdings;\n        uint256 _openLaunchpadTokenCommissions;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"genielaunchpad.storage.EscrowStorage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EscrowStorageLocation =\n        0x44dc4560bd68ecb7d1ace31cc82b462694f73a8c86cd91079a4a43658cbf0500;\n\n    // -----------------------------------------\n    // Events\n    // -----------------------------------------\n    /**\n     * Tokens have been released to beneficiary\n     * @param beneficiary the beneficiary\n     * @param asset the asset released\n     * @param amount the amount released\n     */\n    event Released(\n        address indexed beneficiary,\n        address indexed asset,\n        uint256 amount\n    );\n\n    // -----------------------------------------\n    // Modifiers\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Constructor\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Receive function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Fallback function\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // External functions\n    // -----------------------------------------\n\n    // -----------------------------------------\n    // Public functions\n    // -----------------------------------------\n    /**\n     * @dev Get the amount of ETH or ERC20 tokens or that are currently releaseable (available to be withdrawn) for the caller.\n     * @param token_ The address of the ERC20 token to check, address(0) for ETH\n     * @return The releaseable amount of the given token for the caller.\n     */\n    function releaseable(\n        address token_,\n        address beneficiary\n    ) public view returns (uint256) {\n        return _getEscrowStorage()._holdings[beneficiary][token_];\n    }\n\n    function openLaunchpadTokenCommissions() public view returns (uint256) {\n        return _getEscrowStorage()._openLaunchpadTokenCommissions;\n    }\n\n    // -----------------------------------------\n    // Internal functions\n    // -----------------------------------------\n    function __Escrow_init() internal onlyInitializing {}\n\n    /**\n     * @dev Deposit ETH or ERC20 tokens into the escrow for a specific beneficiary.\n     * @param beneficiary The address of the beneficiary to deposit tokens for.\n     * @param token_ The address of the ERC20 token to deposit, address(0) for ETH\n     * @param amount The amount of tokens to deposit.\n     */\n    function _account(\n        address beneficiary,\n        address token_,\n        uint256 amount\n    ) internal {\n        EscrowStorage storage $ = _getEscrowStorage();\n\n        /* This code is unreachable as handeled by the child contract, leaving a comment for @devs\n        if (beneficiary == address(0)) {\n            revert InvalidAddress();\n        }\n        */\n\n        $._holdings[beneficiary][token_] += amount;\n\n        // Track total open launchpad token commissions\n        if (token_ == getLaunchpadTokenAddress()) {\n            $._openLaunchpadTokenCommissions += amount;\n        }\n    }\n\n    /**\n     * @dev Release deposited ETH or ERC20 tokens for the caller.\n     * @param token_ The address of the ERC20 token to release, address(0) for ETH\n     */\n    function _release(address token_) internal nonReentrant returns (uint256) {\n        EscrowStorage storage $ = _getEscrowStorage();\n\n        uint256 amount = releaseable(token_, msg.sender);\n        if (amount == 0) {\n            revert NothingToRelease();\n        }\n\n        // Optimistic accounting\n        $._holdings[msg.sender][token_] = 0;\n\n        // Track total open launchpad token commissions\n        if (token_ == getLaunchpadTokenAddress()) {\n            $._openLaunchpadTokenCommissions -= amount;\n        }\n\n        // Release ETH\n        if (token_ == address(0)) {\n            /* This code is unreachable as there is no other way to withdraw ETH form the contract \n               leaving a comment for @devs\n            if (address(this).balance < amount) {\n                revert FatalEscrowError();\n            }\n            */\n\n            // Perform the ETH transfer to the caller\n            Address.sendValue(payable(msg.sender), amount);\n        }\n        // Release ERC20\n        else {\n            IERC20 token = IERC20(token_);\n\n            /* This might only ever happen if the payment or the launchpad token is a scam and burns or modifies\n                the launchpad contract balanace externally, for @devs */\n            if (token.balanceOf(address(this)) < amount) {\n                revert FatalEscrowError();\n            }\n\n            // Perform the token transfer to the caller\n            token.safeTransfer(msg.sender, amount);\n        }\n\n        // Emit Released event\n        emit Released(msg.sender, token_, amount);\n        return amount;\n    }\n\n    // -----------------------------------------\n    // Private functions\n    // -----------------------------------------\n    function _getEscrowStorage() private pure returns (EscrowStorage storage $) {\n        assembly {\n            $.slot := EscrowStorageLocation\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"

    },

    "lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"

    },

    "lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Errors.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "forge-std/=lib/forge-std/src/",

      "@chainlink/contracts/=lib/chainlink-evm/contracts/",

      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",

      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",

      "openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 1000

    },

    "metadata": {

      "useLiteralContent": false,

      "bytecodeHash": "ipfs",

      "appendCBOR": true

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "cancun",

    "viaIR": true,

    "libraries": {}

  }

}